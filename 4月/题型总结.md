分治题：     
解题思想：根据题干得到left和right是什么，定义好自己的排序或者比较大小的规则。想好子问题应该怎么解题。                  
题型：快速排序和归并排序，k（链表，数字），构造平衡二叉搜索树，投票算法。        

单调栈:要求一般就一个维度。主要对尾部有要求。(题型：1最)                            
解题思想：根据题干判断         
1.栈的单调性如何满足题目要求  
2.栈内元素和弹出的元素的现实意义     
3.利用几何性质（利用stack的凹槽的现实意义做题）       

单调队列：一般比单调队列多一个或多个维度，主要是对头部的要求。(题型：1范围+1最值)             
解题思想：        
1.头节点是一定范围的最大值还是最小值（最小值说明是单调递增栈，最大值说明是单调递减栈）          
2.头节点什么时候shift出去。             
3.对于一些难题比如需要用到dp就比较难了也不想做了。     

滑动窗口：最短最长子数组/子符串。        
1.满足条件求最短。在while里面设置满足的条件，min = Math.min();     
2.不满足条件求最长。在while里面设置不满足的条件，在while条件外 max = Math.max();  
3.至多多少重复元素：map, 重复元素:set, 特殊条件要求:count，恰巧满足：两个至多相减     
4.满足条件求最长。end和start都需要手动++属于比较难的了，以后再看吧。  

排序十讲：  
1.桶排序（n），基数排序（n）：      
创建桶：       
1）最大值减去最小值除以数组长度。     
2）根据频率分桶      
3）LSD(分位数桶):Math.floor((num-min)/Math.pow(10,i))%10;      
4）MSD:字符串排序   
5）非数值属性进行分组：根据数据项的类别、颜色或其他非数字标识。     

2.三项划分算法（n）：常用于分类排序。    

3.堆排序（nlogn）：原地排序。    

4.归并排序（链表，数组）：找left，找right，找mid。  
