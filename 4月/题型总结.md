**分治题**：     
解题思想：根据题干得到left和right是什么，定义好自己的排序或者比较大小的规则。想好子问题应该怎么解题。                  
题型：快速排序和归并排序，k（链表，数字），构造平衡二叉搜索树，投票算法。        

**单调栈:要求一般就一个维度。主要对尾部有要求。(题型：1最)**                         
解题思想：根据题干判断         
1.栈的单调性如何满足题目要求  
2.栈内元素和弹出的元素的现实意义     
3.利用几何性质（利用stack的凹槽的现实意义做题）       

**单调队列：一般比单调队列多一个或多个维度，主要是对头部的要求。(题型：1范围+1最值)**            
解题思想：        
1.头节点是一定范围的最大值还是最小值（最小值说明是单调递增栈，最大值说明是单调递减栈）          
2.头节点什么时候shift出去。             
3.对于一些难题比如需要用到dp就比较难了也不想做了。     
4.解决最短/最长子数组问题，数组非线性（有负数）。 

**滑动窗口：最短最长子数组/子符串。（满足的条件和窗口大小呈线性关系）**      

<img width="284" alt="截屏2024-04-09 16 38 42" src="https://github.com/xkong-study/ood/assets/100473178/28b372eb-a5b5-4eed-89c9-bd75fe0f7b8a">          

window.size = end-start    
1.满足条件求最短。在while里面设置满足的条件，min = Math.min();     
2.不满足条件求最长。在while里面设置不满足的条件，在while条件外 max = Math.max();  
3.至多多少重复元素：map, 重复元素:set, 特殊条件要求:count，恰巧满足：两个至多相减     
4.满足条件求最长。end和start都需要手动++属于比较难的了，以后再看吧。  

线性条件示例：           

和的大小：对于给定的数列和目标值，找出连续子数组的最小长度，使得子数组的元素和大于等于目标值。这里的线性条件是“元素和大于等于目标值”。窗口扩展（增加窗口右边界）使得和增加，窗口收缩（移动窗口左边界）使得和减少。                   

特定数量的元素：在某些问题中，可能需要在窗口中维持特定类型元素的数量，例如，“最多包含两种不同字符的最长子串”的长度。线性条件是“窗口中不同字符的数量不超过给定值”。窗口扩展可以增加新字符（直到达到类型上限），而窗口收缩则用于减少字符种类，以满足条件。            

达到特定比例或计数：例如，在生物信息学中，可能需要找到DNA序列的一个区域，其中某个核苷酸的比例超过了特定的阈值。这里的线性条件可以是“特定核苷酸的比例”。   

在最短子数组/子字符串问题中，end-start 的线性增加反映了尝试包含更多元素以满足题目条件的过程。一旦条件满足，通过移动 start 指针（即减少 end-start），贪心地寻找更短的满足条件的窗口。     

在最长子数组/子字符串问题中，end-start 的线性增加体现了在满足题目条件下尽可能扩大窗口的尝试，以寻找最长的满足条件的窗口。     


**前缀和+哨兵列** ：非线性。         
一维前缀和：    
1.连续数组：求满足条件的最长的数组（map，value:索引=》只存和的第一个索引），求满足条件的数组的数量（map,value:求个数）。   
2.除：(sum%k+k)%k  
3.和单调队列结合求最短子数组。      
4.差分数组：当我们需要频繁地对一个数组的某个区间内的所有元素进行同一种增减操作时，差分数组能够让这些操作的时间复杂度降低到O(1)，而查询某一元素或某一区间元素的总和的时间复杂度为O(n)。     

二维前缀和：用大的面积减去小面积就得到答案。   

添加一个初始为0的哨兵列（或行），可以使得从任意位置到另一位置的和的计算更加方便。这样做的好处是，你可以直接使用prefixSum[end] - prefixSum[start-1]来计算区间[start, end]的和，而不需要特别处理start为0的情况。    


**双指针**： 双指针技巧通常适用于线性                 
1.反向同速： 一个序列是回文（找中点），或者序列已排序找满足条件的数组。           
2.同向不同速： 比较两个序列并且序列长度不一致，但是要抵达同样的终点。     
3.双指针还可以用来滑动窗口，二分查找，二分排除，左侧二分查找。（我总结了单条线以及多条线的查找法在二分查找总结里）          

<img width="502" alt="截屏2024-04-10 22 00 32" src="https://github.com/xkong-study/ood/assets/100473178/82caa462-d7db-4d9d-bb2c-367bdf5f6d75">


**排序十讲**：  
1.桶排序（n），基数排序（n）：      
创建桶：       
1）最大值减去最小值除以数组长度。     
2）根据频率分桶      
3）LSD(分位数桶):Math.floor((num-min)/Math.pow(10,i))%10;      
4）MSD:字符串排序   
5）非数值属性进行分组：根据数据项的类别、颜色或其他非数字标识。     

2.三项划分算法（n）：常用于分类排序。    

3.堆排序（nlogn）：原地排序。    

4.归并排序（链表，数组）：找left，找right=mid+1，找mid，终止条件（left==right return mid[left]，if(!head || !head.next) return head;）。  

**贪心算法**           
贪心算法题目各种各样有一样就能看出的最优解情况，有需要手动模拟过程推理得出来的最优解，有利用数学公式不等式推理得来的最优解。所以不是很好归纳出来一个一般解法。不能多尝试多模拟。       
有一个思路：就是猜一个最佳的答案然后看看满足什么条件，列出所有需要的条件找就好了。       

**前缀树**    
trie的节点是对象：key为字母，value为{isEnd:true/''};        
前缀树一般和单词搜索一起出现，单词搜索一般分为一维和二维，一维的单词搜索又分为精确找每一个字母 和 找所有的子节点的答案(递归)，一维的前缀树一般是所有单词，二维的单词搜索（是否存在/返回所有答案）就是用dfs+前缀树，二维的前缀树一般是要找的单词，node用来找二维表格里面存在的字母看看存不存在在前缀树里。如果是精准匹配需要node.isEnd == true, 如果是存在前缀index ==  word.length              
