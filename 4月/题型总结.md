**分治题（子问题很好（一般涉及到两个对象的处理）解决升级成k个子问题）**：     
解题思想：根据题干得到left和right是什么，定义好自己的排序或者比较大小的规则。想好子问题应该怎么解题。                  
题型：快速排序和归并排序，k（链表，数字），构造平衡二叉搜索树，投票算法。        

**单调栈:要求一般就一个维度。主要对尾部有要求。(题型：1最)**                         
解题思想：根据题干判断         
1.栈的单调性如何满足题目要求  
2.栈内元素和弹出的元素的现实意义     
3.利用几何性质（利用stack的凹槽的现实意义做题）       

**单调队列：一般比单调队列多一个或多个维度，主要是对头部的要求。(题型：1范围+1最值)**            
解题思想：        
1.头节点是一定范围的最大值还是最小值（最小值说明是单调递增栈，最大值说明是单调递减栈）          
2.头节点什么时候shift出去。             
3.对于一些难题比如需要用到dp就比较难了也不想做了。     
4.解决最短/最长子数组问题，数组非线性（有负数）。 

**滑动窗口：最短最长子数组/子符串。（满足的条件和窗口大小呈线性关系）**      

<img width="284" alt="截屏2024-04-09 16 38 42" src="https://github.com/xkong-study/ood/assets/100473178/28b372eb-a5b5-4eed-89c9-bd75fe0f7b8a">          

window.size = end-start    
1.满足条件求最短。在while里面设置满足的条件，min = Math.min();     
2.不满足条件求最长。在while里面设置不满足的条件，在while条件外 max = Math.max();  
3.至多多少重复元素：map, 重复元素:set, 特殊条件要求:count，恰巧满足：两个至多相减     
4.满足条件求最长。end和start都需要手动++属于比较难的了，以后再看吧。  

线性条件示例：           

和的大小：对于给定的数列和目标值，找出连续子数组的最小长度，使得子数组的元素和大于等于目标值。这里的线性条件是“元素和大于等于目标值”。窗口扩展（增加窗口右边界）使得和增加，窗口收缩（移动窗口左边界）使得和减少。                   

特定数量的元素：在某些问题中，可能需要在窗口中维持特定类型元素的数量，例如，“最多包含两种不同字符的最长子串”的长度。线性条件是“窗口中不同字符的数量不超过给定值”。窗口扩展可以增加新字符（直到达到类型上限），而窗口收缩则用于减少字符种类，以满足条件。            

达到特定比例或计数：例如，在生物信息学中，可能需要找到DNA序列的一个区域，其中某个核苷酸的比例超过了特定的阈值。这里的线性条件可以是“特定核苷酸的比例”。   

在最短子数组/子字符串问题中，end-start 的线性增加反映了尝试包含更多元素以满足题目条件的过程。一旦条件满足，通过移动 start 指针（即减少 end-start），贪心地寻找更短的满足条件的窗口。     

在最长子数组/子字符串问题中，end-start 的线性增加体现了在满足题目条件下尽可能扩大窗口的尝试，以寻找最长的满足条件的窗口。     


**前缀和+哨兵列：连续数组+非线性**         
一维前缀和：    
1.连续数组：求满足条件的最长的数组（map，value:索引=》只存和的第一个索引），求满足条件的数组的数量（map,value:求个数）。   
2.除：(sum%k+k)%k  
3.和单调队列结合求最短子数组。      
4.差分数组：当我们需要频繁地对一个数组的某个区间内的所有元素进行同一种增减操作时，差分数组能够让这些操作的时间复杂度降低到O(1)，而查询某一元素或某一区间元素的总和的时间复杂度为O(n)。   
5.和二分搜索结合找sum最小。       

二维前缀和：用大的面积减去小面积就得到答案。   

添加一个初始为0的哨兵列（或行），可以使得从任意位置到另一位置的和的计算更加方便。这样做的好处是，你可以直接使用prefixSum[end] - prefixSum[start-1]来计算区间[start, end]的和，而不需要特别处理start为0的情况。    


**双指针（查找，两个路程相遇）**： 双指针技巧通常适用于线性                 
1.反向同速： 一个序列是回文（找中点），或者序列已排序找满足条件的数组。           
2.同向不同速： 比较两个序列并且序列长度不一致，但是要抵达同样的终点。     
3.双指针还可以用来滑动窗口，二分查找，二分排除，左侧二分查找。（我总结了单条线以及多条线的查找法在二分查找总结里）          

<img width="502" alt="截屏2024-04-10 22 00 32" src="https://github.com/xkong-study/ood/assets/100473178/82caa462-d7db-4d9d-bb2c-367bdf5f6d75">


**排序十讲**：  
1.桶排序（n），基数排序（n）：      
创建桶：       
1）最大值减去最小值除以数组长度。     
2）根据频率分桶      
3）LSD(分位数桶):Math.floor((num-min)/Math.pow(10,i))%10;      
4）MSD:字符串排序   
5）非数值属性进行分组：根据数据项的类别、颜色或其他非数字标识。     

2.三项划分算法（n）：常用于分类排序。    

3.堆排序（nlogn）：原地排序。    

4.归并排序（链表，数组）：找left，找right=mid+1，找mid，终止条件（left==right return mid[left]，if(!head || !head.next) return head;）。  

**贪心算法**           
贪心算法题目各种各样有一样就能看出的最优解情况，有需要手动模拟过程推理得出来的最优解，有利用数学公式不等式推理得来的最优解。所以不是很好归纳出来一个一般解法。不能多尝试多模拟。       
有一个思路：就是猜一个最佳的答案然后看看满足什么条件，列出所有需要的条件找就好了。       

**前缀树（单词搜索）**     
时间复杂度 建立Trie O(nk)，n是单词数量，K是单词长度         
时间复杂度 搜索O(k),k是单词长度         
trie的节点是对象：key为字母，value为{isEnd:true/''};        
前缀树一般和单词搜索一起出现，单词搜索一般分为一维和二维，一维的单词搜索又分为精确找每一个字母 和 找所有的子节点的答案(递归)，一维的前缀树一般是所有单词，二维的单词搜索（是否存在/返回所有答案）就是用dfs+前缀树，二维的前缀树一般是要找的单词，node用来找二维表格里面存在的字母看看存不存在在前缀树里。如果是精准匹配需要node.isEnd == true, 如果是存在前缀index ==  word.length              

**并查集（可以相交）**                   
一维的省份数量：对什么进行交集（省份），什么时候会交集（1）      二维的岛屿：对什么进行交集（i*width+j）,什么时候会交集（1）.       

解题思路：对什么进行交集，什么时候进行交集，是否存在交集。     
性质：有多少集合，一个集合有多少,集合是否具有连通性。        

利用：     
有多少独立集合这个性质(find)可以用来：       
1.有多少独立岛屿。          
2.是否具有连通性。     

集合是否有交集(union):      
1.岛屿是否合并过=》避免重复搜索。     
2.岛屿在遍历过程中的数量是如何增加的。      

一个集合有多少个数(area)可以用来：      
1.求岛屿的最大面积。        

二维数组在遍历的时候会有重复查找的问题：一个点可能搜索过很多遍这个时候需要标记/通过检查父节点是否相同来判断是否搜索过了。     

**图**     

性质：图的连通性（被围绕的区域）。      

**栈：对称/回文/单调栈（最值）**     

辅助结构：栈，数组，指针，哈希数组。        

碰撞题目：              
不需要思考stack之前旧的情况会发生什么，我们只要考虑每次碰撞的当前情况+状态转换公式就可以了。        

为什么用stack：栈是一种后进先出（LIFO）的数据结构，适用于需要反转顺序或者只关注最近添加的元素的情况。          
在处理车辆碰撞的问题中，使用栈来跟踪和管理车辆的最近状态（比如最近的向右行驶的车辆'R'），方便处理碰撞逻辑。     

为什么只考虑最近状态就好？         
贪心算法：每次都只要考虑到当前情况，就可以把所有的情况都考虑出来。       

如何写if条件判断？       
看看有哪些情况会产生状态转移：      
R+A情况=》B情况。     
那么ifA情况，转换状态+R，whileB情况。      


**链表**   
反转             
解题步骤：  
1.记录开始节点和结束节点          
2.利用pre和cur结束的时候的性质：pre是新链表的头部 cur是下一个链表的开始。      
3.开始节点的下一个节点变成pre，结束节点的下一个节点变成cur。    

合并       
解题步骤：新建一个链表用来装结果,链表A和链表B，合并两个链表。链表A存在合并链表A到新链表。链表B存在合并链表B到新链表。       

找环    
有重复的节点，快慢两个速度，只要满足这两个条件，无论链表还是数组都可以用这龟兔赛跑算法求解。     

必须有一个闭环存在，以便快慢指针最终能相遇。     
必须有一个确定的规则来“前进”，即从一个元素到另一个元素的映射必须是可预测和重复的。     
       
如何制定规则：      
1.制定前进索引：节点，前进索引就是next，数值，前进对象是索引。这个对象和上一个对象要有关系：前一个对象的值当作当前对象的索引就好。            
2.制定前进的对象：有重复的数值，那么前进对象就是数值。有重复的节点，那么制定对象就是节点。     

数组的关系不就只能从两个地方得到的：一个索引，一个数值。所以还能把当前的数值当作之后数的索引。       

删除：    
1.快慢指针+哨兵。    
2.建立前缀和与节点的映射关系。   

复制链表：   
let dummy = new ListNode(0,head);这个单纯就是给head链表加了一个虚拟头节点不起到复制的作用。    

相遇：  
两个链表相遇也一样，同时到达目的地，时间一样的话从速度和路程进行下手。     
