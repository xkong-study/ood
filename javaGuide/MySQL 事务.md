何谓事务？     
我们设想一个场景，这个场景中我们需要插入多条相关联的数据到数据库，不幸的是，这个过程可能会遇到下面这些问题：
数据库中途突然因为某些原因挂掉了。      
客户端突然因为网络原因连接不上数据库了。并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改。      
……上面的任何一个问题都可能会导致数据的不一致性。为了保证数据的一致性，系统必须能够处理这些问题。事务就是我们抽象出来简化这些问题的首选机制。     
事务的概念起源于数据库，目前，已经成为一个比较广泛的概念。    

何为事务？ 一言蔽之，事务是逻辑上的一组操作，要么都执行，要么都不执行。      

原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；     
一致性（Consistency）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；    
隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；    
持久性（Durability）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。    

并发事务带来了哪些问题?     
在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。     

脏读（Dirty read）         
一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。       
这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。     

丢失修改（Lost to modify）          
在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。        
这样第一个事务内的修改结果就被丢失，因此称为丢失修改。              
例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改 A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。       

不可重复读（Unrepeatable read）------ delete/update   
指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。       
那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。      
例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。        

幻读（Phantom read）---- insert       
幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。        
在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。      
例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。        

不可重复读和幻读有什么区别？       
不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；      
幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。       
幻读其实可以看作是不可重复读的一种特殊情况，单独把幻读区分出来的原因主要是解决幻读和不可重复读的方案不一样。        
举个例子：执行 delete 和 update 操作的时候，可以直接对记录加锁，保证事务安全。         
而执行 insert 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。       
也就是说执行 insert 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。         



事务隔离级别和脏读。    

在数据库系统中，事务隔离级别定义了一个事务中的操作可以被其他事务看到的程度。最常见的隔离级别包括：     

读未提交（Read Uncommitted）：       

这是最低的隔离级别，它允许事务读取其他事务尚未提交的修改。即使这些修改最终没有被提交（例如，被回滚），它们仍然是对其他运行在“读未提交”级别的事务可见的。     
在这个级别，事务A可以修改了一条记录但还没有提交，事务B可以看到这个修改，这就产生了脏读。    

读已提交（Read Committed）：        

在这个级别，一个事务只能看到其他事务已经提交的修改。这可以防止脏读，因为你只读取已经被确认提交到数据库的数据。         

可重复读（Repeatable Read）：           

这个级别保证在整个事务期间可以多次读取同一记录的结果是一样的。这个级别防止了脏读和不可重复读（另一个事务的更新影响到当前事务的相同查询结果）。        

串行化（Serializable）：      

这是最高的隔离级别，通过对涉及的数据进行锁定（行锁或表锁），来防止脏读、不可重复读和幻读。这基本上使得事务被完全顺序执行，防止了并发访问的所有问题。      

如何读到未提交的数据        
在“读未提交”级别下，当一个事务修改了数据但尚未提交时，这些未提交的数据是对其他同时运行在“读未提交”级别的事务可见的。这通常是通过数据库管理系统（DBMS）的内部机制实现的，其中事务在修改数据时不会立即将其写入数据库的主存储区，而是在某种形式的临时存储中保留更改。这样，其他事务就可以访问这些还未最终提交的修改。        

设置隔离级别示例     
在SQL中，可以设置事务的隔离级别以允许或禁止脏读。例如，在SQL Server中，你可以如此设置隔离级别：     

```code
-- 设置为读未提交，允许脏读
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

-- 开始事务
BEGIN TRANSACTION;

-- 执行查询
SELECT * FROM mytable;

-- 提交或回滚事务
COMMIT TRANSACTION;
```


