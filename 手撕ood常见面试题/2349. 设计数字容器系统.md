这道题很有思考价值，我本来想着有索引又不需要增删那直接arrayList不就可以了，但是提交发现超出内存限制，那就只能用哈希表了呀！！！！
在此之前先复习一下arrayList的写法：
当讨论ArrayList的自动扩容问题时，主要关注以下几个方面：    
  
1. 自动扩容机制     
ArrayList在添加元素时（使用add(E e)方法）set的添加方法不可以完成扩容，如果内部数组的容量不足以容纳新元素，ArrayList会自动扩大容量来存储更多元素。这个过程称为“自动扩容”。     

2. 扩容过程     
扩容通常涉及以下步骤：    

创建一个新的数组，其容量大于当前数组。通常，新容量是旧容量的1.5倍（即旧容量加上旧容量的一半），但这个增长率不是Java规范定义的，不同版本的JDK实现可能略有不同。    
将旧数组中的所有元素复制到新数组中。    
将ArrayList的内部引用更新为新数组。    

3. 扩容的性能影响     
每次扩容操作都涉及创建新数组和复制旧数组元素到新数组，这是一个相对昂贵的操作，特别是对于大型数组。因此，如果你预先知道ArrayList将要存储的元素数量，使用带有初始容量参数的构造函数ArrayList(int initialCapacity)来避免多次扩容可能会更高效。    
 
4. 避免频繁扩容的策略     
预估容量：如果能预估数据量的大小，最好在创建ArrayList时就指定一个足够大的初始容量。    
批量添加操作：如果一次性要添加多个元素，使用addAll(Collection<? extends E> c)可能比多次调用add(E e)更有效，因为addAll可以根据需要添加的元素数量一次性计算扩容。     
 
5. ensureCapacity(int minCapacity)方法        
ArrayList提供了ensureCapacity(int minCapacity)方法，允许手动增加ArrayList的容量。如果minCapacity大于当前容量，ArrayList将会扩容以确保它至少能容纳minCapacity数量的元素。这是一种优化手段，用于减少自动扩容的次数。



```code
class NumberContainers {
    List<Integer> list;
    public NumberContainers() {
    list = new ArrayList<>();
    }
    
    public void change(int index, int number) {
    if(index>=list.size()){
    list.addAll(Collections.nCopies(index - list.size() + 1, 0));
    }
    list.set(index,number);
    }
    
    public int find(int number) {
    if(list.contains(number)) return list.indexOf(number);
    return -1;
    }
}
```

提到的Collections.nCopies(index - list.size() + 1, 0)这个例子中，这个方法被用来创建一个包含(index - list.size() + 1)个0的列表。这通常用于扩展现有的ArrayList到指定的索引index，以便能够安全地使用.set(index, element)方法进行元素设置，而不会抛出IndexOutOfBoundsException异常。


当然上面的写法是会超出内存的，那么比arrayList更加高效并且也方便查找增加删除的那就是hashMap，nc.find(10); // 数字 10 所在的下标为 1 ，2 ，3 和 5 。因为最小下标为 1 ，所以返回 1 。但是再读题，需要这个那么就是能排序还能提高内存高效就是TreeSet平衡树的方法了。

在Java的HashMap中，使用put(key, value)方法来添加或更新键值对时，如果指定的键（在这个场景中是index）已经存在于HashMap中，那么新的值（number）会替换旧的值。这是因为每个键在HashMap中是唯一的，它不能映射到多个值。    

方法一：平衡树（有序集合）

用hashMap存储旧的索引和值，用Map<Integer,TreeSet<Integer>> map存储<number,TreeSet<index1,index2,index2>>可以自动排序。

```code
class NumberContainers {
    Map<Integer,Integer> hashMap = new HashMap<>();
    Map<Integer,TreeSet<Integer>> map = new HashMap<>();
    public NumberContainers() {
    }
    
    public void change(int index, int number) {
    var old = hashMap.get(index);
    if(old != null){
        map.get(old).remove(index);
    }
    hashMap.put(index,number);
    map.computeIfAbsent(number,k->new TreeSet<>()).add(index);
    }
    
    public int find(int number) {
    var s = map.get(number);
    return s == null || s.isEmpty() ? -1 : s.first();
    }
}
```

向 TreeSet 中添加 index:    

.add(index) 这部分是对从 map 中得到的 TreeSet 对象进行操作。无论这个 TreeSet 是新创建的还是已经存在的，我们都使用 add 方法将 index 添加到这个 TreeSet 中。这个操作是直接在 TreeSet 上执行的，与 map 的直接操作无关。这个 add 操作确保了 index 被添加到了 number 对应的下标集合中。   

