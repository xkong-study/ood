**前缀树:insert+search**     
前缀树其实是对象树        
时间复杂度 建立Trie O(nk)，n是单词数量，K是单词长度。     
时间复杂度 搜索O(k),k是单词长度        
trie的节点是对象：key为字母，value为{isEnd:true/''};       
题型：211添加与搜索单词 - 数据结构设计   添加和搜索单词    岛屿数量II      
遍历：trie.children[char], node.children[char];      
前缀树一般和单词搜索一起出现，单词搜索一般分为一维和二维：    
一维:前缀树    
二维:dfs+前缀树      

```code
let trie = {
    children: {
        'a': { /* 子节点 */ },
        'b': { /* 子节点 */ }
    }
};


{
    c: {
        a: {
            t: { isEnd: true },
            p: { isEnd: true }
        }
    }
}

let node = {
    t: { isEnd: true },
    p: { isEnd: true }
};

for (let child in node) {
    console.log(child);  // 输出 't' 然后是 'p'
}
```

```code
var Trie = function(){
    this.children = {};
}

Trie.prototype.insert = function(word){
    let node = this.children;
    for(const cn of word){
        if(!node[cn]){
            node[cn] = {};
        }
        node = node[cn];
    }
    node.isEnd = true;
}

Trie.prototype.search = function(prefix){
    let node = this.children;
    for(const cn of prefix){
        if(!node[cn]){
           return false;
        }
        node = node[cn];
    }
if(node.isEnd==true) return node;
}
```


**并查集:find+union+size 合并父节点**   
带集合大小的，不带集合大小的+路径压缩+秩来减少时间复杂度为lg*n，无限接近于1。                 
解题思路：对什么进行交集，什么时候进行交集，是否存在交集。合并的条件+合并什么（索引+单元格+城市），利用find，union，size，根节点三个性质解题。        

题型：省份数量 岛屿数量一和二，一很简单都不需要用并查集的数据结构，直接用思想就好，二需要并查集数据结构循环判断       
一维的省份数量：对什么进行交集（省份），什么时候会交集（1）      
二维的岛屿：对什么进行交集（i*width+j）,什么时候会交集（1)       

性质：有多少集合，一个集合有多少,集合是否具有连通性。     

```code
function DSU(n){
    this.parent = new Array(n);//存节点的父节点
    this.rank = new Array(n);//存节点局里父节点的距离。  
    this.area = new Array(n).fill(1);
    
    for(let i = 0; i < n; i++){
        this.parent[i] = i;
        this.rank[i] = 0;
    }
}

DSU.prototype.find = function(x) {
    if (this.parent[x] !== x) {
        this.parent[x] = this.find(this.parent[x]);
    }
    return this.parent[x];
};

DSU.prototype.union = function(x, y) {
    let rootX = this.find(x);
    let rootY = this.find(y);

    if (rootX !== rootY) {
        if (this.rank[rootX] < this.rank[rootY]) {
            this.parent[rootX] = rootY;
            this.area[rootY] += this.area[rootX];
        } else if (this.rank[rootX] > this.rank[rootY]) {
            this.parent[rootY] = rootX;
            this.area[rootX] += this.area[rootY];
        } else {
            this.parent[rootY] = rootX;
            this.rank[rootX]++;
            this.area[rootX] += this.area[rootY];
        }
    }
    
    return this.area[this.find(x)];
};

```

利用：
有多少独立集合这个性质(find)可以用来：
1.有多少独立岛屿。
2.是否具有连通性。

集合是否有交集(union):
1.岛屿是否合并过=》避免重复搜索。
2.岛屿在遍历过程中的数量是如何增加的。

一个集合有多少个数(area)可以用来：
1.求岛屿的最大面积。

二维数组在遍历的时候会有重复查找的问题：一个点可能搜索过很多遍这个时候需要标记/通过检查父节点是否相同来判断是否搜索过了。

图    

性质：图的连通性（被围绕的区域）。     

**栈和队列:辅助**      
栈的入栈和出栈的时间复杂度都很小为O(1)      
辅助结构：栈，数组，指针，哈希数组。    
解题思路：主要是设计题：辅助数组，辅助栈，双指针front和rear指针        
题型：设计一个支持增量操作的栈，设计循环双端队列，设计循环队列，用栈实现队列，最小栈。      

**栈：状态转换**         
碰撞经典题。       
解题模版：新球碰撞+旧球碰撞+没有碰撞（旧球飞走了，新球飞走了，栈为空）。           
题型：一个速度不一样一个速度一样，速度不一样的只看地点和结束的运行时间从小到大排序，然后找局部范围的极大值看有没有比他大的有就说明不是一个车队的，这个也是求集合的经典模版，速度一样的分为3种情况写RS，SL，RL。       

我自己的解题模版：    
不需要思考stack之前旧的情况会发生什么，我们只要考虑每次碰撞的当前情况+状态转换公式就可以了。    

为什么用stack：栈是一种后进先出（LIFO）的数据结构，适用于需要反转顺序或者只关注最近添加的元素的情况。
在处理车辆碰撞的问题中，使用栈来跟踪和管理车辆的最近状态（比如最近的向右行驶的车辆'R'），方便处理碰撞逻辑。

为什么只考虑最近状态就好？
贪心算法：每次都只要考虑到当前情况，就可以把所有的情况都考虑出来。

如何写if条件判断？
看看有哪些情况会产生状态转移：
R+A情况=》B情况。
那么ifA情况，转换状态+R，whileB情况。


**单调栈:要求一般就一个维度。主要对尾部有要求。线性(题型：1最)**                         
解题思想：根据题干判断         
1.栈的单调性如何满足题目要求  
2.栈内元素和弹出的元素的现实意义     
3.利用几何性质（利用stack的凹槽的现实意义做题，利用stack的凸出的现实意义做题）    
4.必要的时候加辅助数组/哈希      

**单调队列VS滑动窗口**        

![3731714496131_ pic](https://github.com/xkong-study/ood/assets/100473178/9720ec7a-aa54-42a4-9efe-f145ba0b73de)

**单调队列：一般比单调队列多一个或多个维度，主要是对头部的要求。线性(题型：1范围+1最值+所求的东西和数据成非线性经过队列pop之后呈线性关系)**   
<img width="483" alt="截屏2024-04-29 21 13 44" src="https://github.com/xkong-study/ood/assets/100473178/579b6d4c-1559-4b51-b74b-91f4de2b3057">
<img width="554" alt="截屏2024-04-29 21 16 23" src="https://github.com/xkong-study/ood/assets/100473178/2464947d-8ae3-49bb-98e2-117cb2e055c6">
<img width="510" alt="截屏2024-04-29 21 23 46" src="https://github.com/xkong-study/ood/assets/100473178/c0ca07ce-5344-4351-b545-7ef42bb1e3e6">

解题思想：        
1.头节点是一定范围的最大值还是最小值（最小值说明是单调递增栈，最大值说明是单调递减栈）          
2.头节点什么时候shift出去。             
3.对于一些难题比如需要用到dp就比较难了也不想做了。     
4.解决最短/最长子数组问题，数组非线性（有负数=>前缀和）。 

**滑动窗口：最短最长子数组/子符串。（条件和窗口大小呈线性关系：当问题条件与窗口的内容直接相关，且窗口的调整（增加或减少元素）可以直观地影响这些条件时，滑动窗口特别有效。）**      

<img width="284" alt="截屏2024-04-09 16 38 42" src="https://github.com/xkong-study/ood/assets/100473178/28b372eb-a5b5-4eed-89c9-bd75fe0f7b8a">          

window.size = end-start    
1.满足条件求最短。在while里面设置满足的条件，min = Math.min();     
2.不满足条件求最长。在while里面设置不满足的条件，在while条件外 max = Math.max();  
3.至多多少重复元素：map, 重复元素:set, 特殊条件要求:count，恰巧满足：两个至多相减。           
4.满足条件求最长。end和start都需要手动++属于比较难的了，以后再看吧。  
5. K个不同整数的子数组（最多k个不同整数的子数组-最多k-1个不同整数的子数组）     
6.end-start+1: 除了用来求数组长度还可以用来求以end结尾的子数组连续部分的所有子数组个数。     
7.最短字符串找： minStart + minLen       

线性条件示例：           

和的大小：对于给定的数列和目标值，找出连续子数组的最小长度，使得子数组的元素和大于等于目标值。这里的线性条件是“元素和大于等于目标值”。窗口扩展（增加窗口右边界）使得和增加，窗口收缩（移动窗口左边界）使得和减少。                   

特定数量的元素：在某些问题中，可能需要在窗口中维持特定类型元素的数量，例如，“最多包含两种不同字符的最长子串”的长度。线性条件是“窗口中不同字符的数量不超过给定值”。窗口扩展可以增加新字符（直到达到类型上限），而窗口收缩则用于减少字符种类，以满足条件。            

达到特定比例或计数：例如，在生物信息学中，可能需要找到DNA序列的一个区域，其中某个核苷酸的比例超过了特定的阈值。这里的线性条件可以是“特定核苷酸的比例”。   

在最长子数组/子字符串问题中，end-start 的线性增加体现了在满足题目条件下尽可能扩大窗口的尝试，以寻找最长的满足条件的窗口。     

**前缀和+哨兵列：连续数组+非线性**         
一维前缀和：    
1.连续数组：求满足条件的最长的数组（map，value:第一个索引），求满足条件的数组的数量（map,value:求个数）。   
2.除：(sum%k+k)%k  
3.和单调队列结合求最短子数组。      
4.差分数组：当我们需要频繁地对一个数组的某个区间内的所有元素进行同一种增减操作时，差分数组能够让这些操作的时间复杂度降低到O(1)，而查询某一元素或某一区间元素的总和的时间复杂度为O(n)。   
5.和二分搜索结合找sum最小。       

二维前缀和：用大的面积减去小面积就得到答案。   

添加一个初始为0的哨兵列（或行），可以使得从任意位置到另一位置的和的计算更加方便。这样做的好处是，你可以直接使用prefixSum[end] - prefixSum[start-1]来计算区间[start, end]的和，而不需要特别处理start为0的情况。    



**链表：合并，反转，删除，有环，复制，结构转换**       
合并，反转，删除，有环，复制，结构转换。    

反转     
解题步骤：   
1.记录开始节点和结束节点    
2.利用pre和cur结束的时候的性质：pre是新链表的头部 cur是下一个链表的开始。    
3.开始节点的下一个节点变成pre，结束节点的下一个节点变成cur。   

合并     
解题步骤：新建一个链表用来装结果,链表A和链表B，合并两个链表。链表A存在合并链表A到新链表。链表B存在合并链表B到新链表。     

找环     
有重复的节点，快慢两个速度，只要满足这两个条件，无论链表还是数组都可以用这龟兔赛跑算法求解。     
必须有一个闭环存在，以便快慢指针最终能相遇。     
必须有一个确定的规则来“前进”，即从一个元素到另一个元素的映射必须是可预测和重复的。    

如何制定规则：     
1.制定前进索引：节点，前进索引就是next，数值，前进对象是索引。这个对象和上一个对象要有关系：前一个对象的值当作当前对象的索引就好。     
2.制定前进的对象：有重复的数值，那么前进对象就是数值。有重复的节点，那么制定对象就是节点。      

数组的关系不就只能从两个地方得到的：一个索引，一个数值。所以还能把当前的数值当作之后数的索引。      

删除：     
1.快慢指针+哨兵。    
2.建立前缀和与节点的映射关系。     

复制链表：     
let dummy = new ListNode(0,head);这个单纯就是给head链表加了一个虚拟头节点不起到复制的作用。     

相遇：     
两个链表相遇也一样，同时到达目的地，时间一样的话从速度和路程进行下手。       

**扫描题：并集，交集，差集，补集**      
并集，交集，差集，补集（范围内减去交集）模版全部列出。    

并集：   
```code
var merge = function(intervals) {
intervals.sort((a,b)=>a[0]-b[0]);
let pre = intervals[0];
let ans = [];
for(let i=1;i<intervals.length;i++){
    let cur = intervals[i];
    if(cur[0]<=pre[1]){
        pre[1] = Math.max(cur[1],pre[1]);
    }
    else{
        ans.push(pre)
        pre = cur;
    }
}
ans.push(pre)
return ans;
};

```

交集：    
```code
var intervalIntersection = function(firstList, secondList) {
let i=0;
let j=0;
let ans = [];
while(i<firstList.length && j<secondList.length){
    let max = Math.max(firstList[i][0],secondList[j][0]);
    let min = Math.min(firstList[i][1],secondList[j][1]);
    if(max<=min){
        ans.push([max,min]);
    }
    if(firstList[i][1]<secondList[j][1]){
        i++;
    }
    else{
        j++;
    }
}
return ans;
};
```

补集:    
```code
function employeeFreeTime(schedule) {
    let allIntervals = [];
    for (let intervals of schedule) {
        allIntervals.push(...intervals);
    }

    let mergedIntervals = mergeIntervals(allIntervals);
    let freeTimes = [];
    for (let i = 1; i < mergedIntervals.length; i++) {
        if (mergedIntervals[i - 1][1] < mergedIntervals[i][0]) {
            freeTimes.push([mergedIntervals[i - 1][1], mergedIntervals[i][0]]);
        }
    }

    return freeTimes;
}

function mergeIntervals(intervals) {
    intervals.sort((a, b) => a[0] - b[0]);

    let res = [];
    let pre = intervals[0];
    for (let i = 1; i < intervals.length; i++) {
        let cur = intervals[i];
        if (pre[1] >= cur[0]) {
            pre[1] = Math.max(cur[1], pre[1]);
        } else {
            res.push(pre);
            pre = cur;
        }
    }
    res.push(pre);

    return res;
}
```

差集（找独立的集合）：   
```code
var removeCoveredIntervals = function(intervals) {
intervals.sort((a,b)=>b[1]!=a[1]?b[1]-a[1]:a[0]-b[0]);
let ans = 0;
let pre = intervals[0]
for(let i=1;i<intervals.length;i++){
    let cur = intervals[i];
    if(pre[0]<=cur[0]){
        ans++;
    }
    else{
        pre = cur;
    }
}
return intervals.length-ans;
};
```

数独立的个数：排序结束点的值，删除或者缺失需分类讨论，    
上车下车问题map    
解题思路：判断怎么排序+画图模拟过程/分类画图总结出规律。     

根据区间终点进行升序排序     

适用场景：当问题涉及到寻找最少的区间以避免重叠，或者是要最大化选择的区间数量（使得每个区间都与前一个区间不重叠），通常会选择根据区间的终点进行升序排序。    
原因：    
选择终点最早的区间可以最大化后续选择的空间，因为它留下了更多的空间给后面的区间，减少了重叠的可能性。    
这是一种贪心策略，通过局部最优选择（即每次选择终点最早的区间），来达到全局最优（即最大化不重叠区间的数量或最小化需要移除的区间数）。    
例子：eraseOverlapIntervals 函数就是一个例子，目标是通过移除最少数量的区间来消除所有重叠，因此按照区间终点升序排序。    
  
根据区间起点进行升序排序      

适用场景：当问题要求处理区间的覆盖关系，或者需要按照区间的自然顺序逐个考察区间时，通常会选择根据区间的起点进行升序排序。     
原因：     
按起点排序后，可以便于判断一个区间是否被另一个区间完全覆盖（因为如果一个区间被另一个覆盖，那么它的起点和终点都会在另一个区间的起点和终点之间）。    
对于处理区间的合并、插入或覆盖等问题，起点排序提供了一种自然和直观的方式来逐个处理区间，特别是在需要考虑区间之间相对位置关系的情境。    
例子：removeCoveredIntervals 函数就是一个例子，目的是移除所有被其他区间完全覆盖的区间，因此按照区间起点升序排序，如果起点相同则按终点降序排序，以便于处理覆盖关系。     

以下是一些常见的排序方式：    

根据区间起点排序   
intervals.sort((a, b) => a[0] - b[0]);    
适用场景：合并区间、计算区间覆盖长度、查找区间交集等。这种排序方式有助于顺序处理区间，特别是当你需要基于区间起点进行决策时。    
  
根据区间终点排序     
intervals.sort((a, b) => a[1] - b[1]);     
适用场景：寻找区间的最大不重叠子集、安排会议室等。当你需要优先考虑区间的结束而不是开始时，这种排序方式非常有用。    

根据区间长度排序     
intervals.sort((a, b) => (a[1] - a[0]) - (b[1] - b[0]));     
适用场景：有时候可能需要根据区间的长度来进行特定的逻辑处理，比如寻找最长的连续区间，或者是处理与区间长度相关的优化问题。    

根据区间起点排序，起点相同则根据终点排序      
intervals.sort((a, b) => a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]);    
适用场景：这种排序方式在需要根据区间的起点进行主要排序，但在起点相同的情况下需要考虑终点作为次要排序条件的场景中很有用，比如复杂的区间合并问题或特定类型的区间查询。          

根据区间终点排序，终点相同则根据起点排序 intervals.sort((a, b) => a[1] === b[1] ? a[0] - b[0] : a[1] - b[1]); 适用场景：当需要首先考虑区间的结束点，但在结束点相同的情况下又要根据起点进一步排序时使用。这种方式在某些特定的区间排列或选择问题中可能会有用。          

**DFS对比BFS解题侧重点**       

BFS:迷宫，课程表，单词接龙 =》 最短路径 + 逐层扩展 + 避免重复访问（level+queue）      

这个运用方式和找出最短路径的迷宫题很想都是利用dfs和bfs但是不是用来返回答案的而是用来判断路径/解法是否可行的。    

DFS:解数独，n皇后 =〉 是否可能存在解（dfs返回true/false） 解是什么（dfs不返回值） + 约束条件多(level+是否可以选择的节点)      

找答案：        
   
BFS：每一层找出（这一层所有可能的答案里面）最优的答案，往往需要辅助数组记录最优     

DFS：通过严格的要求需要满足承上（回溯）启下（递归）找出唯一的答案            

判断是否可行：     
dfs/bfs返回true和false；      

总结起来，广度优先搜索（BFS）通常用于寻找最短路径或最优解的问题，因为它能够有效地探索多个可能性并按层次逐步扩展搜索范围，以确保找到的解决方案是最优的。BFS还能够避免重复访问相同的节点，提高搜索效率。     

而深度优先搜索（DFS）则通常用于需要穷尽所有可能性的问题，尤其是在需要回溯和处理大量约束条件的情况下。DFS在搜索过程中通常只会得到一种可能的解法，或者用于判断是否存在解决方案，而不会得到最优解。     

因此，BFS适用于需要找到最短路径或最优解的问题，而DFS适用于需要穷尽所有可能性或判断解决方案是否存在的问题。在问题的解空间比较大或者有很多约束条件时，DFS可能会更合适，因为它的搜索策略更加灵活，可以逐步探索所有可能性。      

**bfs：level+queue**     
![image](https://github.com/xkong-study/ood/assets/100473178/7f23f6f3-7edc-4582-b113-0f13646e08a1)

题型：                
拓扑排序（先找关系关系找到了找权重，然后bfs遍历去掉权重是0的节点，一点点减去权重减去节点，节点放入order数组）课程表和课程表II（比较order是否节点完整），都是这样写的）     
拓扑排序：      
Indegree 是节点的被连接次数    
被连接次数为0的时候就是作为node 的时候     
[节点，被连接的节点]     
所以解题关键就是看谁当节点谁当被连接的节点      

在处理课程和先修课程关系时，我们使用一个 map 来存储每个课程的后续课程。然而，如果某个课程没有后续课程，map 中将不会包含这个课程。所以我们需要把每一个课程都存储进map.      

树        
二维数组      
最短路径       

BFS解题步骤：    

1.level:判断需要不需要同时处理同一层的所有节点=》遍历queue.length。level的实际意义是什么作为二叉树很明显是指层但是作为拓扑排序那么level就是指权重。                        
2.queue:判断n叉树的n是什么=>子节点是什么。          

3.是否存在求最值情况，注意避免搜索过量加visited标记。       

4.剪纸去重

BFS:     
level: 用来记录最短/最快     
queue：运动四个方向，26个字母     
去重： width*row + col => visited      

**dfs:level+是否可以选择的节点**      
一维表格：一个level（row）：有哪几个level，每一个level（dfs(level++)）有多少种可以选择子节点（for col）。                     
二维表格：两个level：row和col都为level。      
一维数组：level+子节点+去重。           
题型：二维数组（解数独），二叉树（前序遍历），还有一些常见题全排列，子集，组合。                  
去重思路：不同层不能有相同的头节点（我要先区分不同层再比较有没有相同的节点）      

参见我画的图：      

<img width="363" alt="截屏2024-04-29 21 32 09" src="https://github.com/xkong-study/ood/assets/100473178/3cf064dd-d8b3-421e-8579-43adc9461231"> 

解题思路：       
1.识别决策点的分支数量：       
首先，确定每个决策点有多少个可行的选择路径。这可能是单一路径、两条路径，或者是多条路径，需要通过循环来遍历。              
for循环是为了找到所有可能子节点，具体求子节点后面的所有集合数那么就是用递归找到，如果超出循环条件了就pop回溯。           
决策/路径次数：多条路径（for）,单一路径，两条路径(if)。        
 
2.确定搜索的维度：         
判断需要执行的是一维DFS还是二维DFS。这取决于问题的具体情况，比如是需要在数组中寻找子集，还是处理类似“几个人每个人带多少帽子”这样的多维情景。二维的dfs主要就是知道：求谁，求谁的什么子集就可以了，比如每个人戴不同帽子，求谁：人，每个人的什么子集；帽子，所以就是循环每个人可以带的帽子，用sum里面的索引对应每一个人。再比如说：完成所有工作的最短时间： 求谁：工人，什么子集：每一个工人的工作有哪些可能性，所以循环什么；工作任务清单，对应每一个工人，这样每一个工人的所有可能结果都能求出来。 说的更形象就是子集问题，是一维的，那么求每一个人带的帽子就是求每一个人对应可能的帽子子集，所以每一个人都要求一遍子集所以用sum的索引记录求每一个子集，这就是多了一个维度！           

3.判断路径的唯一性：            
对于每一个选择的路径，检查是否已经在之前的搜索中考虑过。如果这些路径在之前的决策点中已被探索，我们可以使用记忆化搜索以避免重复计算；如果未被探索过，则继续进行深度搜索。 memo(new Map(索引，索引对应结果))。        

**普通递归 VS dfs**       
就是判断路径是否需要回溯：        
dfs有显示回溯和隐式回溯两种：      
隐式回溯通常发生在使用递归实现DFS时，尤其是在不需要修改全局或外部变量的情况下。在隐式回溯中，函数的局部变量在每次递归调用时都会创建新的副本。         
特点：        
不可变数据：在递归过程中传递不可变数据（如整数、字符串或不可变集合），使得每个递归调用都保持数据的原始状态。     
无需撤销操作：由于每次递归调用都使用数据的副本，返回到递归的上一层时无需进行任何撤销或恢复操作，因为之前的状态自然保留在了调用栈中。   

显式回溯则是在使用DFS递归探索时，需要直接修改全局变量或传递可变对象（如列表或集合），并在探索完一条路径后，显式地将这些变量或对象恢复到原始状态。     
特点：     
可变数据的使用：通常涉及对全局变量或传递到递归函数中的可变对象进行修改。      
需要撤销操作：每当DFS递归调用返回后，必须显式撤销在递归中所做的更改，以便其他递归路径可以从未被修改的状态开始。     

**普通递归**：普通递归一般都能找到f(n)=f(n-1)这种公式，直接递归调用，无需状态管理，通常没有多分支决策。很多时候都用二分查找实现比如找平方根，求平方数。      


**二分查找：left+right+几条线段**                     
线性的/已排序。        
相错终止：主要用于确定元素不存在的情况。    
相等终止：用于查找元素的准确位置。当left和right重合时，它们指向的位置就是目标元素的位置（如果目标元素存在）。         
  题型：   
  1.查找满足条件的和（和的单调性解题）。                      
  2.查找满足条件的元素。       
  3.查找满足条件的第一个元素,求转折点。（左侧二分查找法）         
  4.二分排除法。        
  解题想法：题干发现是有序的，根据单调性找出left和right就可以求了。            
  二分查找分为分治法和减治法。        
         
各种线段，多个线段的查找目标数的方法都有了。   
找target：第一个bad version     如何缩小范围：判断是否是坏版本   利用性质：分界点   
注意left<right 避免循环无法跳出。   
<img width="254" alt="截屏2024-04-29 21 34 50" src="https://github.com/xkong-study/ood/assets/100473178/236e8b1c-6b6f-4017-80ad-be1ad9e7400f">

找target：最小的数      如何缩小范围：比较right的值      利用性质：旋转数组通过缩小范围找到其中一个序列=》数组有序性      
用mid和right进行分区查找。     
<img width="348" alt="截屏2024-04-29 21 33 15" src="https://github.com/xkong-study/ood/assets/100473178/825828ee-4165-4083-9a1e-515f34833856">

找target：题目的target   如何缩小范围：比较mid和target     利用性质：数组有序性      
<img width="265" alt="截屏2024-04-29 21 34 20" src="https://github.com/xkong-study/ood/assets/100473178/d9733437-d460-431a-a046-351985294852">

找target:找两个序列的中位数 如何缩小范围：不断比较k/2分别在两个序列的数值进行排除    利用性质：数组有序性。     
<img width="411" alt="截屏2024-04-11 17 49 34" src="https://github.com/xkong-study/ood/assets/100473178/598df739-121a-46ac-bc48-c5d956c4430c">


**双指针（查找，两个路程相遇）**： 双指针技巧通常适用于线性                 
1.反向同速： 一个序列是回文（找中点），或者序列已排序找满足条件的数组。           
2.同向不同速： 比较两个序列并且序列长度不一致，但是要抵达同样的终点。     
3.双指针还可以用来滑动窗口，二分查找，二分排除，左侧二分查找。（我总结了单条线以及多条线的查找法在二分查找总结里）          

<img width="502" alt="截屏2024-04-10 22 00 32" src="https://github.com/xkong-study/ood/assets/100473178/82caa462-d7db-4d9d-bb2c-367bdf5f6d75">

**排序十讲**：  
1.桶排序（n），基数排序（n）：      
创建桶：       
1）最大值减去最小值除以数组长度。     
2）根据频率分桶      
3）LSD(分位数桶):Math.floor((num-min)/Math.pow(10,i))%10;      
4）MSD:字符串排序   
5）非数值属性进行分组：根据数据项的类别、颜色或其他非数字标识。     

2.三项划分算法（n）：常用于分类排序。    

3.堆排序（nlogn）：原地排序。    

4.归并排序（链表，数组）：找left，找right=mid+1，找mid，终止条件（left==right return mid[left]，if(!head || !head.next) return head;）。  

**贪心算法**           
贪心算法题目各种各样有一样就能看出的最优解情况，有需要手动模拟过程推理得出来的最优解，有利用数学公式不等式推理得来的最优解。所以不是很好归纳出来一个一般解法。不能多尝试多模拟。       
有一个思路：就是猜一个最佳的答案然后看看满足什么条件，列出所有需要的条件找就好了。   

**大问题拆成小问题**     
1.递归     
2.迭代     
3.分治     
