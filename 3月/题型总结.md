**前缀树:** 
n叉树+key是单词value是节+isEnd赋予属性 211添加与搜索单词 - 数据结构设计   添加和搜索单词    岛屿数量II              

**并查集:**                 
带集合大小的，不带集合大小的+路径压缩+秩来减少时间复杂度为lg*n，无限接近于1。                 
解题思路：合并的条件+合并什么（索引+单元格+城市），利用find，union，size，根节点三个性质解题。        
题型：省份数量 岛屿数量一和二，一很简单都不需要用并查集的数据结构，直接用思想就好，二需要并查集数据结构循环判断       

**栈和队列:**
栈的入栈和出栈的时间复杂度都很小为O(1)       
解题思路：主要是设计题：辅助数组，辅助栈，双指针front和rear指针
题型：设计一个支持增量操作的栈，设计循环双端队列，设计循环队列，用栈实现队列，最小栈。  

**链表：**
合并，反转，删除，有环，复制，结构转换。    
解题思路：      
合并：新建一个链表用来装结果,链表A和链表B，合并两个链表。链表A存在合并链表A到新链表。链表B存在合并链表B到新链表。  
题型：两数相加，合并两个有序链表，合并k个升序链表，两数相加II。     
反转：    
解题思路：  
1.记录开始节点和结束节点    
2.利用pre和cur结束的时候的性质：pre是新链表的头部 cur是下一个链表的开始。      
3.开始节点的下一个节点变成pre，结束节点的下一个节点变成cur。   
题型：反转链表I，反转链表II，k个一组反转链表。  
有环：快慢指针，快指针走两步，慢指针走1步。   
题型：环形链表I，环形链表II，快乐数，重复数。 
删除：快慢指针+哨兵
复制：创建新的链表存储head特别是就链表的指针遭遇到破坏那么head就会不一样   
题型：相交链表。  

**栈：**
碰撞经典题。       
解题模版：新球碰撞+旧球碰撞+没有碰撞（旧球飞走了，新球飞走了，栈为空）。           
题型：一个速度不一样一个速度一样，速度不一样的只看地点和结束的运行时间从小到大排序，然后找局部范围的极大值看有没有比他大的有就说明不是一个车队的，这个也是求集合的经典模版，速度一样的分为3种情况写RS，SL，RL。  

**扫描题：**      
合并题型：排序开始起点的值。         
数独立的个数：排序结束点的值，删除或者缺失需分类讨论，           
上车下车问题map，      
交集就是获取两个集合的最大值和最小值，不用排序。             

**bfs：**     
题型：                
拓扑排序，先找关系关系找到了找权重，然后bfs遍历去掉权重是0的节点，一点点减去权重减去节点，节点放入order数组）课程表和课程表II（比较order是否节点完整），都是这样写的。      
树=》bfs都是比较基础的二叉树层序遍历题。        
二维数组=〉bfs，这个都是单词搜索啊迷宫，迷宫II这种题。这种题不要忘记标记访问过的地方提高速度。比如单词搜索这种线性的就是谁先到终点谁快，不需要标记走了多少步不像迷宫II每一步的步数都不一样所以不可以用线性表示快慢要多一个标记计步数。    

**dfs:**             
dfs代码的每一个执行步骤和回溯条件以及新递归的条件代码都清楚了：       
题型：二维数组（解数独），二叉树（前序遍历），还有一些常见题全排列，子集，组合      

解题思路：     
1.识别决策点的分支数量：
首先，确定每个决策点有多少个可行的选择路径。这可能是单一路径、两条路径，或者是多条路径，需要通过循环来遍历。          
for循环是为了找到所有可能子节点，具体求子节点后面的所有集合数那么就是用递归找到，如果超出循环条件了就pop回溯。        
决策/路径次数：多条路径（for）,单一路径，两条路径(if)。       

2.确定搜索的维度：        
判断需要执行的是一维DFS还是二维DFS。这取决于问题的具体情况，比如是需要在数组中寻找子集，还是处理类似“几个人每个人带多少帽子”这样的多维情景。二维的dfs主要就是知道：求谁，求谁的什么子集就可以了，比如每个人戴不同帽子，求谁：人，每个人的什么子集；帽子，所以就是循环每个人可以带的帽子，用sum里面的索引对应每一个人。再比如说：完成所有工作的最短时间： 求谁：工人，什么子集：每一个工人的工作有哪些可能性，所以循环什么；工作任务清单，对应每一个工人，这样每一个工人的所有可能结果都能求出来。 说的更形象就是子集问题，是一维的，那么求每一个人带的帽子就是求每一个人对应可能的帽子子集，所以每一个人都要求一遍子集所以用sum的索引记录求每一个子集，这就是多了一个维度！     

3.判断路径的唯一性：            
对于每一个选择的路径，检查是否已经在之前的搜索中考虑过。如果这些路径在之前的决策点中已被探索，我们可以使用记忆化搜索以避免重复计算；如果未被探索过，则继续进行深度搜索。 memo(new Map(索引，索引对应结果))。        
   

**二分查找：**
线性的/已排序。        
相错终止：主要用于确定元素不存在的情况。    
相等终止：用于查找元素的准确位置。当left和right重合时，它们指向的位置就是目标元素的位置（如果目标元素存在）。         
  题型：   
  1.查找满足条件的和（和的单调性解题）。                      
  2.查找满足条件的元素。       
  3.查找满足条件的第一个元素,求转折点。（左侧二分查找法）         
  4.二分排除法。        
  解题想法：题干发现是有序的，根据单调性找出left和right就可以求了。            
  二分查找分为分治法和减治法。    
  
各种线段，多个线段的查找目标数的方法都有了。   
找target：第一个bad version     如何缩小范围：判断是否是坏版本   利用性质：分界点              
<img width="425" alt="截屏2024-04-11 17 38 58" src="https://github.com/xkong-study/ood/assets/100473178/4c043c83-fa6a-4e3e-a76d-10781dd4dd56">

找target：最小的数      如何缩小范围：比较right的值      利用性质：旋转数组通过缩小范围找到其中一个序列=》数组有序性                             
<img width="516" alt="截屏2024-04-11 17 41 16" src="https://github.com/xkong-study/ood/assets/100473178/f482878b-f793-41e8-960d-0d269fcd830a">

找target：题目的target   如何缩小范围：比较mid和target     利用性质：数组有序性      
<img width="449" alt="截屏2024-04-11 17 42 20" src="https://github.com/xkong-study/ood/assets/100473178/391d4ccd-352e-4c12-aeba-0fa4d1e62622">

找target:找两个序列的中位数 如何缩小范围：不断比较k/2分别在两个序列的数值进行排除    利用性质：数组有序性。     
<img width="411" alt="截屏2024-04-11 17 49 34" src="https://github.com/xkong-study/ood/assets/100473178/598df739-121a-46ac-bc48-c5d956c4430c">


